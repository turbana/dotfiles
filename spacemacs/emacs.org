#+TITLE: Spacemacs Config
#+STARTUP: content

* Initial
** Lexical binding
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+END_SRC
** Secrets
I'll store my secrets in a gpg encrypted ini file, so we first need a function
to return values from an ini file.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/read-from-ini (ini-file section key)
    "Open INI-FILE and return the KEY found under [SECTION]."
    (with-temp-buffer
      (insert-file-contents ini-file)
      (goto-char (point-min))
      (search-forward-regexp (concat "^ *\\[" section "\\]"))
      (let ((max (or (save-excursion
                       (search-forward-regexp "^ *\\[" nil t))
                     (point-max))))
        (search-forward-regexp (concat "^ *" key " *= *") max)
        (buffer-substring (point) (point-at-eol)))))
#+END_SRC

Now let's setup emacs to use =gpg2= and a helper function to read from my secrets file.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq epg-gpg-program "gpg2")
  (setq ic/secrets-file "~/.etc/secrets/secrets.ini.gpg")

  (defun ic/read-secret (section key)
    (ic/read-from-ini ic/secrets-file section key))
#+END_SRC
** Debugging
*** Tracing
Some functions to trace the changing of variables.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (symbol value operation buffer)
      (message (ic//watch-variable-format symbol buffer operation value))
    (ic/watch-variable-call-func symbol #'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (symbol value operation buffer)
      (let ((msg (ic//watch-variable-format symbol buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol #'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (symbol value operation buffer)
      (message (ic//watch-variable-format symbol buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol #'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (symbol value operation buffer)
        (when (member operation ops)
          (apply func (list symbol value operation buffer))))
      (add-variable-watcher symbol #'watch-change)
      (push (cons symbol #'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC
*** Profiling
Some profiler keybindings.
#+BEGIN_SRC emacs-lisp :tangle no
  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))

  (spacemacs/declare-prefix "E" "emacs")
  (spacemacs/set-leader-keys "Ec" #'ic/start-cpu-profiler)
  (spacemacs/set-leader-keys "Em" #'ic/start-mem-profiler)
  (spacemacs/set-leader-keys "Es" #'profiler-stop)
  (spacemacs/set-leader-keys "Er" #'profiler-report)
#+END_SRC

* Major Packages
** org-mode
*** Basic Setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files '("~/org" "~/org/home"))
  (setq org-default-notes-file "~/org/refile.org")
  (setq org-archive-location "%s_archive::")
  (setq ic/org-capture-template-dir "~/.etc/spacemacs/org-capture-templates/")
#+END_SRC
*** Refile
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC
*** Keybinds
I want =, r= to refile rather than =, R=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (spacemacs/set-leader-keys-for-major-mode 'org-mode "r" 'org-refile)
#+END_SRC
**** Agenda
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-<f1>") 'org-clock-goto)
  (global-set-key (kbd "<f12>") 'org-agenda)
#+END_SRC
**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/org-refile ()
    "call C-u `org-refile'"
    (interactive)
    (setq current-prefix-arg '(1))
    (call-interactively 'org-refile))
  (spacemacs/set-leader-keys "aoj" 'ic/org-refile)
#+END_SRC
**** Normal mode navigation
#+BEGIN_SRC emacs-lisp :tangle yes
  (evil-define-key 'normal org-mode-map (kbd "<left>") 'outline-up-heading)
  (evil-define-key 'normal org-mode-map (kbd "<up>") 'org-backward-heading-same-level)
  (evil-define-key 'normal org-mode-map (kbd "<down>") 'org-forward-heading-same-level)
  (evil-define-key 'normal org-mode-map (kbd "<right>") 'outline-next-visible-heading)

  (evil-define-key 'normal org-mode-map (kbd "S-<left>") 'org-promote-subtree)
  (evil-define-key 'normal org-mode-map (kbd "S-<up>") 'org-move-subtree-up)
  (evil-define-key 'normal org-mode-map (kbd "S-<down>") 'org-move-subtree-down)
  (evil-define-key 'normal org-mode-map (kbd "S-<right>") 'org-demote-subtree)

  (evil-define-key 'normal org-mode-map (kbd "C-S-<left>") 'org-do-promote)
  (evil-define-key 'normal org-mode-map (kbd "C-S-<right>") 'org-do-demote)
#+END_SRC
*** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation t)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: E \equal{} \gamma{}mc^2
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-pretty-entities t)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]].
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; ⚫•⦾⦿—⬎⌄⌵
  (setq org-bullets-bullet-list '("•"))
  (setq org-ellipsis " ⌵")
  (setq ic/org-list-icon "—")
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 ()
           (compose-region (match-beginning 1)
                           (match-end 1)
                           ic/org-list-icon))))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-hide-emphasis-markers t)
#+END_SRC
*** Agenda
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)
  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)
  ;; show weekly agenda by default
  (setq org-agenda-span 'week)
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(("a" "Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            (tags "-refile/"
                  ((org-agenda-overriding-header "Archive tasks:")
                   (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                   (org-tags-match-list-sublevels nil))))
           ((org-agenda-block-separator "1")
            (org-agenda-compact-blocks t)
            (org-agenda-tag-filter-preset '("-HOME"))
            ))
          ("h" "Home agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            (tags "-refile/"
                  ((org-agenda-overriding-header "\nArchive tasks:")
                   (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                   (org-tags-match-list-sublevels nil)))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores-PRIORITY=\"A\"|jobs-PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))))
            )
           ((org-agenda-block-separator "1")
            (org-agenda-compact-blocks t)
            (org-agenda-tag-filter-preset '("+HOME"))
            ))
          ))
  ;; don't have a separator between agenda sections
  (setq org-agenda-block-separator "2")
  (setq org-agenda-compact-blocks nil)
#+END_SRC
*** Habits
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 2)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today t)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC
*** Todo
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(a@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC
*** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC
*** Capture
**** Templates
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("r" "respond" entry (file org-default-notes-file)
           "* TODO respond to %:from on %:subject\nscheduled: %t\n%u\n%a\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")
          ("P" "meal plan" entry (file+olp+datetree ic/recipes-plan-file "Planning")
           (file ,(concat ic/org-capture-template-dir "meal-plan.org"))
           :immediate-finish t
           :time-prompt t
           :tree-type week)
          ))
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC
**** Full Frame
The standard =org-capture= behavior is to split the window before capturing a
task. When this is started from outside emacs a random buffer occupies half the
frame. What I want is the capture buffer to take the full frame when starting
the capture from outside emacs. My window manager will start the capture task
with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook
where it splits the frame we'll need to advise it to ~(delete-other-windows)~
when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC
*** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; show current clock in the modeline
  (setq spacemacs-mode-line-org-clock-current-taskp t)
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  (org-clock-persistence-insinuate)
#+END_SRC
*** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp :tangle yes\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml :tangle yes\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
#+END_SRC
*** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want
to see most everything else.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC
*** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/org-recipe-publish-to-html (plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC
** TODO disk-usage
So we can see how much crap there is.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package disk-usage)
#+END_SRC
** mu4e
First, setup mu.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-maildir "~/mail")
  ;; (setq mu4e-mu-binary "/usr/local/bin/mu")
  (setq mu4e-get-mail-command "offlineimap -o")
#+END_SRC

We can only check our gmail accounts once every 10 minutes or we risk a ban.
#+BEGIN_QUOTE
Make sure your mail app isn't set to check for new email too frequently. If your mail app checks for new messages more than once every 10 minutes, the app’s access to your account could be blocked.
#+END_QUOTE
More information [[https://support.google.com/mail/answer/7126229?p=BadCredentials&visit_id=636868193607658613-796315695&rd=2#cantsignin][here]].

#+BEGIN_SRC emacs-lisp :tangle no
  (setq mu4e-update-interval 600)
#+END_SRC

Then, some common variables.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; show images inline
  (setq mu4e-view-show-images t)
  (setq mu4e-show-images t)
  ;; show addresses rather than names
  (setq mu4e-view-show-addresses t)
  ;; strip html when viewing emails...
  (setq mu4e-html2text-command "w3m -dump -T text/html")
  ;; ... and allow me to open an email in a browser
  (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser) t)
  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
  ;; quit silently
  (setq mu4e-confirm-quit nil)
#+END_SRC

Have a slightly different layout when showing an inbox.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; different date format
  (setq mu4e-headers-date-format "%Y-%m-%d %H:%M")
  ;; set header fields
  (setq mu4e-headers-fields
        '((:date    . 17)
          (:flags   . 6)
          (:from    . 32)
          (:subject . nil)))
#+END_SRC

We need a helper function to determine what context we're in automatically.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; taken from: https://notanumber.io/2016-10-03/better-email-with-mu4e/
  (defun ic//mu4e-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
            ;; If rx is a list, try each one for a match
            (or (ic//mu4e-maildir-matches msg (car rx))
                (ic//mu4e-maildir-matches msg (cdr rx)))
          ;; Not a list, check rx
          (string-match rx (mu4e-message-field msg :maildir)))))
#+END_SRC

Some default gmail setup.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq message-send-mail-function 'smtpmail-send-it)
  ;; (setq smtpmail-default-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-service 587)
  ;; (setq smtpmail-stream-type 'starttls)
  ;; (setq smtpmail-smtp-local-domain "gmail.com")
#+END_SRC

For each of our gmail accounts we need an application specific password to use
to send email. To create one go [[https://security.google.com/settings/u/1/security/apppasswords][here]]. Be sure and insert a line into
=~/.authinfo.gpg= for each account with the following format:
#+BEGIN_EXAMPLE
machine smtp.gmail.com port 587 login <user>@gmail.com password <account password>
#+END_EXAMPLE

Now some account specific setup
#+BEGIN_SRC emacs-lisp :tangle no
  ;; This sets up my two different context for my personal and work emails.
  (setq mu4e-contexts
        (let ((professional-address (ic/read-secret "gmail-professional" "address"))
              (professional-name (ic/read-secret "gmail-professional" "name"))
              (personal-address (ic/read-secret "gmail-personal" "address"))
              (personal-name (ic/read-secret "gmail-personal" "name")))
          `( ,(make-mu4e-context
               :name "professional-gmail"
               :enter-func `(lambda () (mu4e-message (concat "Switch to " ,professional-address)))
               :match-func (lambda (msg)
                             (when msg
                               (ic//mu4e-maildir-matches msg "^/gmail-professional")))
               :leave-func (lambda () (mu4e-clear-caches))
               :vars `((user-mail-address     . ,professional-address)
                       (user-full-name        . ,professional-name)
                       (mu4e-sent-folder      . "/gmail-professional/sent")
                       (mu4e-drafts-folder    . "/gmail-professional/drafts")
                       (mu4e-trash-folder     . "/gmail-professional/trash")
                       (mu4e-refile-folder    . "/gmail-professional/inbox") ; XXX What should this be?
                       (smtpmail-smtp-user    . ,professional-address)
                       ))
              ,(make-mu4e-context
                :name "home-gmail"
                :enter-func (lambda () `(mu4e-message (concat "Switch to " ,personal-address)))
                :match-func (lambda (msg)
                              (when msg
                                (ic//mu4e-maildir-matches msg "^/gmail-personal")))
                :leave-func (lambda () (mu4e-clear-caches))
                :vars `((user-mail-address     . ,personal-address)
                        (user-full-name        . ,personal-name)
                        (mu4e-sent-folder      . "/gmail-personal/sent")
                        (mu4e-drafts-folder    . "/gmail-personal/drafts")
                        (mu4e-trash-folder     . "/gmail-personal/trash")
                        (mu4e-refile-folder    . "/gmail-personal/inbox")
                        (smtpmail-smtp-user    . ,personal-address)
                        )))))

  ;; compose under the current context
  (setq mu4e-compose-context-policy nil)
#+END_SRC

Message composing should be done in =org-mode= format and sent as html.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; automatically flow text when sending
  (setq mu4e-compose-format-flowed t)

  ;; enter org-mode when composing
  (add-hook 'message-mode-hook 'org-mu4e-compose-org-mode)

  ;; export org-mode into html when sending
  (setq org-mu4e-convert-to-html t)

  ;; (setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC
** Cooking
*** Configuration
First, we need to setup some configuration.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq ic/recipes-org-file "~/org/home/recipes.org")
  (setq ic/recipes-plan-file "~/org/home/food.org")
  (setq ic/recipian-web-root "~/src/recipian-web/")
  (setq ic/github-pages-repo "git@github.com:turbana/turbana.github.io.git")
  (setq ic/recipian-recipes-json (concat ic/recipian-web-root
                                           "src/assets/recipes.json"))
  (setq ic/recipian-plan-json (concat ic/recipian-web-root
                                      "src/assets/plan.json"))
  (setq ic/node-bin-dir "~/apps/node-v10.15.3-linux-x64/bin/")
  (setq ic/github-pages-url "https://turbana.github.io")
#+END_SRC

*** Site Generation
Now I need a build script to generate the supporting files, build, and then push
the angular site.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/recipian-generate-push-production ()
    "Generate recipian-web and push to production."
    (interactive)
    (defun git-commit-maybe (filename)
      (when (eq 'edited (vc-git-state filename))
        (let ((short-name (file-name-nondirectory filename)))
          (message "git commit %s" short-name)
          (vc-git-checkin (list filename) "updated %s" short-name))))
    (let ((debug-on-error t)
          (default-directory ic/recipian-web-root) ; needed for vc-git
          ;; (process-environment (append (list (concat "PATH="
          ;;                                            (getenv "PATH")
          ;;                                            ":"
          ;;                                            (expand-file-name ic/node-bin-dir)))
          ;;                              process-environment))
          needs-rebuild)
      ;; generate json files
      (ic/recipian-generate-asset-files)
      ;; commit to git
      (git-commit-maybe ic/recipian-recipes-json)
      (git-commit-maybe ic/recipian-plan-json)
      ;; rebuild prod angular
      (message "rebuilding angular...")
      (call-process (concat ic/node-bin-dir "ng")
                    nil "*AngularBuild*" t
                    "build" "--prod"
                    "--base-href" ic/github-pages-url)
      ;; build github pages
      (message "angular ghpages...")
      (call-process (concat ic/node-bin-dir "npx")
                    nil "*AngularBuild*" t
                    "angular-cli-ghpages"
                    "--dir" "dist/recipian-web"
                    "--branch" "master"
                    "--repo" ic/github-pages-repo
                    "--no-silent")
      (message "recipian-web generated")))


  (defun ic/recipian-generate-asset-files ()
    "Generate supporting files for recipian-web."
    (interactive)
    ;; XXX force reload of the package during development
    (load "~/.etc/spacemacs/private-layers/ian/local/recipian/recipian.el")
    ;; generate recipes.json
    (recipian-write-json ic/recipian-recipes-json
                         (recipian-parse-recipes ic/recipes-org-file))
    ;; generate plan.json
    (recipian-write-json ic/recipian-plan-json
                         (recipian-parse-plans ic/recipes-plan-file))
    (message "Generated assets for recipian-web"))
#+END_SRC

And some keybinds to run them.
#+BEGIN_SRC emacs-lisp :tangle yes
  (spacemacs/set-leader-keys "Br" #'ic/recipian-generate-asset-files)
  (spacemacs/set-leader-keys "BR" #'ic/recipian-generate-push-production)
#+END_SRC

*** Refiling
I keep cooking tasks in a date tree. When rescheduling the date tree becomes out
of sync with it's schedule. The following will automatically refile a
rescheduled entry to where it needs to go.

Inspired by [[https://stackoverflow.com/questions/26648731/refile-existing-entry-to-different-location-in-org-mode-date-tree][this stackoverflow post]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/org-schedule-refile-meal-plans (&rest args)
    "Automatically refile meal plans to the correct datetree after rescheduling."
    (interactive "P")
    (let ((buffer-file-name (expand-file-name (buffer-file-name)))
          (plan-file-name (expand-file-name ic/recipes-plan-file)))
      (when (and (equal buffer-file-name plan-file-name)
                 (member (org-get-todo-state)
                         (list "PREP" "COOK")))
        (org-with-wide-buffer
         (let* ((datetree-date (org-entry-get nil "SCHEDULED" t))
                (date (org-date-to-gregorian datetree-date))
                (pos (save-excursion
                       (org-datetree-find-iso-week-create date)
                       (point))))
           (org-refile nil nil
                       (list nil buffer-file-name nil pos)
                       "Updated datetree")))
        (org-refile-goto-last-stored)
        ;; we have to update the note marker here so org will write :LOGBOOK:
        ;; entries in the right place
        (move-marker org-log-note-marker (point)))))

  (advice-add 'org-schedule :after #'ic/org-schedule-refile-meal-plans)
#+END_SRC

*** Meal Planning
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic//meal-plan (date)
    "Bring up the meal plan for the week containing DATE."
    (interactive "P")
    (let* ((date-iso (calendar-iso-from-absolute
                      (calendar-absolute-from-gregorian
                       date)))
           (year (nth 2 date-iso))
           (week (nth 0 date-iso))
           (groceries (calendar-gregorian-from-absolute
                       (calendar-iso-to-absolute
                        (list (1- week) 7 year)))))
      ;; open meal plan file
      (find-file ic/recipes-plan-file)
      (widen)
      (goto-char (point-min))
      ;; move to the week node and create it, if it doesn't exist
      (condition-case nil
          (re-search-forward (format "^*+ %d-W%s$" year week))
        ((search-failed e)
         ;; create each date entry
         (dotimes (day 7)
           (let* ((date-iso (list week (1+ day) year))
                  (date (calendar-gregorian-from-absolute
                         (calendar-iso-to-absolute date-iso))))
             (org-datetree-find-iso-week-create date)))
         ;; go to the parent week
         (org-up-element)
         (org-end-of-line)
         ;; add an empty grocery list
         (save-excursion
           (org-insert-subheading "")
           (insert "TODO Groceries\n")
           (org-schedule nil (calendar-date-string groceries))
           (insert "| Item | Amount |\n")
           (insert "|------+--------|\n")
           (insert "|      |        |\n"))))
      ;; narrow to week
      (org-narrow-to-subtree)))


  (defun ic/meal-plan-this-week ()
    "Bring up the meal plan for this week."
    (interactive)
    (ic//meal-plan (calendar-current-date)))



  (defun ic/meal-plan-next-week ()
    "Bring up the meal plan for the upcoming week."
    (interactive)
    (save-window-excursion
    (ic//meal-plan (calendar-current-date 7)))
    )


  (spacemacs/set-leader-keys "aop" 'ic/meal-plan-this-week)
  (spacemacs/set-leader-keys "aoP" 'ic/meal-plan-next-week)
#+END_SRC

* Programming
** General
*** Indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/setup-indentation-hook (tab-width use-tabs)
    "Create a mode-hook that will setup indentation variables."
    `(lambda ()
       (setq indent-tabs-mode ,use-tabs)
       (setq tab-width ,tab-width)
       (setq js-indent-level ,tab-width)
       (setq python-indent ,tab-width)))
  (let ((indentation-setup
         '(
           (asm-mode-hook 8 t)
           (emacs-lisp-mode-hook 2 nil)
           (lisp-mode-hook 2 nil)
           (makefile-mode-hook 8 t)
           (python-mode-hook 4 nil)
           )))
    (dolist (elem indentation-setup)
      (add-hook (car elem)
                (apply #'ic/setup-indentation-hook (cdr elem)))))
  ;; use tabs by default
  (setq-default indent-tabs-mode t)
  (setq-default tab-width 4)
#+END_SRC
** Python
*** Linter
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq flycheck-checker-error-threshold 1024)
#+END_SRC
** Lisp
*** Indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; better indentation of quoted lists
  (setq lisp-indent-function 'common-lisp-indent-function)
#+END_SRC
* Misc
** Fonts
Setup both monospaced and non-monospaced fonts.

Some good variable spaced fonts:
- Century Schoolbook L
- TeX Gyre Pagella
- Utopia
- Caladea
- Gentium
- Gillius ADF
- URW Palladio L

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar ic/fixed-pitch-font '("DejaVu Sans Mono" 11.0))
  (defvar ic/variable-pitch-font '("Gillius ADF" 13.0))

  (defun ic/setup-fonts (fixed-pitch-font variable-pitch-font)
    (cl-flet ((make-size (size)
             (truncate (* 10 size))))
      (let ((fixed-family (first fixed-pitch-font))
            (fixed-height (make-size (second fixed-pitch-font)))
            (variable-family (first variable-pitch-font))
            (variable-height (make-size (second variable-pitch-font))))
        (custom-theme-set-faces
         'user
         `(default ((t (:family ,fixed-family :height ,fixed-height))))
         `(fixed-pitch ((t (:family ,fixed-family :height ,fixed-height))))
         `(variable-pitch ((t (:family ,variable-family :height ,variable-height))))
         ))))
  (ic/setup-fonts ic/fixed-pitch-font ic/variable-pitch-font)
#+END_SRC

** Variable pitch
=org-mode= should be mostly variable pitch with only code and =company-mode= being
fixed width.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar ic/org-faces-fixed-pitch
    '(company-echo
      company-echo-common
      company-preview
      ;; keep this variable pitched as it's used on the same line as the input
      ;; text (which is variable).
      ;; company-preview-common
      company-preview-search
      company-scrollbar-bg
      company-scrollbar-fg
      company-template-field
      company-tooltip
      company-tooltip-annotation
      company-tooltip-annotation-selection
      company-tooltip-common
      company-tooltip-common-selection
      company-tooltip-mouse
      company-tooltip-search
      company-tooltip-search-selection
      company-tooltip-selection
      linum
      org-block
      org-block-begin-line
      org-block-end-line
      org-checkbox
      org-code
      org-date
      org-document-info-keyword
      org-hide
      org-indent
      org-link
      org-meta-line
      org-special-keyword
      org-table
      whitespace-space
      )
    "A list of faces that should remain fixed width when enabling `variable-pitch-mode'.")

  (defun ic//variable-pitch-add-inherit (attrs parent)
    "Add `:inherit PARENT' to ATTRS unless already present. Handles cases where :inherit is already specified."
    (let ((current-parent (plist-get attrs :inherit)))
      (unless (or (eq parent current-parent)
                  (and (listp current-parent) (member parent current-parent)))
        (plist-put attrs :inherit (if current-parent
                                      (list current-parent parent)
                                    parent)))))

  (defun ic/variable-pitch-mode ()
    (variable-pitch-mode 1)
    (mapc
     (lambda (face)
       (when (facep face)
         (apply 'set-face-attribute
                face nil (ic//variable-pitch-add-inherit
                          (face-attr-construct face)
                          'fixed-pitch))))
     ic/org-faces-fixed-pitch))

  (add-hook 'org-mode-hook #'ic/variable-pitch-mode)
#+END_SRC

** Ediff
I want to press =d= and remove all diff formats from buffer =C=. This is helpful
when merging in git to take both branches.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/ediff-copy-both-to-c ()
    "Copy both sets of changes from `A' and `B' into `C'."
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))

  (defun ic/add-custom-keys-to-ediff ()
    (define-key ediff-mode-map "c" 'ic/ediff-copyy-both-to-c))

  (add-hook 'ediff-keymap-setup-hook 'ic/add-custom-keys-to-ediff)
#+END_SRC

** Dim inactive buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't
dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for
color customization.

#+BEGIN_SRC emacs-lisp :tangle yes
  (auto-dim-other-buffers-mode t)
  (setq auto-dim-other-buffers-dim-on-focus-out t)
  (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
#+END_SRC

** Web Browser
Use whatever we have as =web= as default browser
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "web")
#+END_SRC
** Clipboard
Use system clipboard
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq x-select-enable-primary t)
#+END_SRC
** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of
the re-display code so can run only when needed. Lisp implementations such as
=linum= and =nlinum= have to run over an entire window as they can't know which part
of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain
text-heavy modes.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-linum-mode -1)
  (linum-relative-global-mode -1)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also
want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use lines displayed on screen rather than new line characters
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 2 ...
  (setq-default display-line-numbers-width 2)
  ;; ... and allow it grow, but not shrink
  (setq-default display-line-numbers-grow-only t)
#+END_SRC

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like
=linum-mode=, instead it uses the =text-area= where the main buffer text is. This
means that anything in the fringe (=display-margin=) now shows up to the left
of the line numbers. I'm not a fan of that, but I guess I'll live with it as
there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of
=display-line-numbers= for more info.

** Text Wrap
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Fill Column
#+BEGIN_SRC emacs-lisp :tangle yes
  (turn-on-fci-mode)
#+END_SRC
** Search
Disable search highlighting
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-evil-search-highlight-persist 0)
#+END_SRC
** Customize
Disable customize by having emacs write customize variables to a file that is
never loaded.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file (concat user-emacs-directory "ignore-custom.el"))
#+END_SRC
** Helm
*** Keybinds
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key helm-map (kbd "C-w") 'backward-kill-word)
#+END_SRC
** Evil
*** Keybinds
When editing an =org-src= block =:w= should save the parent buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/evil-save-src-block-advice (evil-write &rest args)
    "When edit an org-src block `:w' should call `(org-edit-src-save)'."
    (if (string-prefix-p "*Org Src" (buffer-name))
        (org-edit-src-save)
      (apply evil-write args)))

  (advice-add #'evil-write :around #'ic/evil-save-src-block-advice)
#+END_SRC
** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to
use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/save-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (let ((spacemacs-really-kill-emacs nil))
      (save-buffer)
      (kill-buffer-and-window)))

  (defun ic/prompt-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (let ((spacemacs-really-kill-emacs t))
        (save-buffers-kill-emacs))))

  ;; set spacemacs keys
  (spacemacs/set-leader-keys "qq" 'spacemacs/frame-killer)
  (spacemacs/set-leader-keys "qQ" 'ic/prompt-kill-emacs)

  ;; set evil keys
  (evil-ex-define-cmd "q[uit]" 'kill-buffer-and-window)
  (evil-ex-define-cmd "wq" 'ic/save-kill-buffer-and-window)
#+END_SRC
** Garbage Collection
Spacemacs has a really large value for =gc-cons-threshold= (100mb), let's change
this back to the default and see how things feel.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (setq gc-cons-threshold 8000000)
  ;; TEMP let's see *when* gc occurs
  (setq garbage-collection-messages t)
#+END_SRC

** TODO Mode Line
I'd like to clean up my mode line and only show certain minor-modes, but some
seem to be having problems. =which-key-mode= in particular sets =minor-mode-alist=
as it runs clobbering my settings.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun ic/diminish-minor-mode (mode &optional to-what)
    "Change MODE in the mode line TO-WHAT."
    (let ((minor (assq mode minor-mode-alist))
          (new-val (or to-what "")))
      (if minor
          (setcdr minor (list new-val))
        (error "%s is not a valid minor-mode" mode))))

  (let ((diminish-modes
         '((buffer-face-mode " vp")
           (auto-dim-other-buffers-mode)
           (org-src-mode " OS")
           (spacemacs-whitespace-cleanup-mode)
           (smartparens-mode)
           ;; (which-key-mode)
           (company-mode)
           (evil-org-mode "")
           )))
    (dolist (mode diminish-modes)
      (message "%S" mode)
      (apply #'ic/diminish-minor-mode mode)
      ;; (diminish-undo (car mode))
      ;; (apply #'diminish mode)
      ))
  ;; (diminish 'buffer-face-mode "vp")
  ;; (diminish 'auto-dim-other-buffers-mode nil)
  ;; (diminish 'evil-org-mode nil)
  ;; (diminish 'which-key-mode "YYY")
  ;; (diminished-modes)

  ;; (ic/diminish-minor-mode 'which-key-mode)
  ;; (setcdr (assq 'which-key-mode minor-mode-alist) (list ""))
  ;; (assq 'which-key-mode minor-mode-alist)
  ;; (setq-default which-key-lighter "   ")
#+END_SRC

* Refile
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq create-lockfiles nil)
  (setq magit-diff-refine-hunk 'all)
  (setq powerline-default-separator 'contour)
#+END_SRC
