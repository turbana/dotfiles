#+TITLE: Spacemacs Config
#+STARTUP: content

* Initial
** Lexical binding
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+END_SRC
** Secrets
I'll store my secrets in a gpg encrypted ini file, so we first need a function
to return values from an ini file.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/read-from-ini (ini-file section key)
    "Open INI-FILE and return the KEY found under [SECTION]."
    (with-temp-buffer
      (insert-file-contents ini-file)
      (goto-char (point-min))
      (search-forward-regexp (concat "^ *\\[" section "\\]"))
      (let ((max (or (save-excursion
                       (search-forward-regexp "^ *\\[" nil t))
                     (point-max))))
        (search-forward-regexp (concat "^ *" key " *= *") max)
        (buffer-substring (point) (point-at-eol)))))
#+END_SRC

Now let's setup emacs to use =gpg2= and a helper function to read from my secrets file.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq epg-gpg-program "gpg2")
  (setq ic/secrets-file "~/.etc/secrets/secrets.ini.gpg")

  (defun ic/read-secret (section key)
    (ic/read-from-ini ic/secrets-file section key))
#+END_SRC
** Debugging
*** Tracing
Some functions to trace the changing of variables.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to '(set), see
  `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (symbol value operation buffer)
      (message "%s(%s): %s '%s'" symbol buffer operation value))
    (ic/watch-variable-call-func symbol #'watch-variable-call-message ops))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-error (symbol value operation buffer)
      (error "symbol %S changed to '%S'" symbol value))
    (ic/watch-variable-call-func symbol #'watch-variable-raise-debug ops))

  (defvar ic//variable-watchers nil "alist of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (symbol value operation buffer)
        (when (member operation ops)
          (apply func (list symbol value operation buffer))))
      (add-variable-watcher symbol #'watch-change)
      (push (cons symbol #'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))
#+END_SRC
* Major Packages
** org-mode
*** Basic Setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-agenda-files '("~/org" "~/org/home"))
  (setq org-default-notes-file "~/org/refile.org")
  (setq org-archive-location "%s_archive::")
#+END_SRC
*** Refile
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC
*** Keybinds
I want =, r= to refile rather than =, R=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (spacemacs/set-leader-keys-for-major-mode 'org-mode "r" 'org-refile)
#+END_SRC
**** Agenda
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-<f1>") 'org-clock-goto)
  (global-set-key (kbd "<f12>") 'org-agenda)
#+END_SRC
**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/org-refile ()
    "call C-u `org-refile'"
    (interactive)
    (setq current-prefix-arg '(1))
    (call-interactively 'org-refile))
  (spacemacs/set-leader-keys "aoj" 'ic/org-refile)
#+END_SRC
**** Normal mode navigation
#+BEGIN_SRC emacs-lisp :tangle yes
  (evil-define-key 'normal org-mode-map (kbd "<left>") 'outline-up-heading)
  (evil-define-key 'normal org-mode-map (kbd "<up>") 'org-backward-heading-same-level)
  (evil-define-key 'normal org-mode-map (kbd "<down>") 'org-forward-heading-same-level)
  (evil-define-key 'normal org-mode-map (kbd "<right>") 'outline-next-visible-heading)

  (evil-define-key 'normal org-mode-map (kbd "S-<left>") 'org-promote-subtree)
  (evil-define-key 'normal org-mode-map (kbd "S-<up>") 'org-move-subtree-up)
  (evil-define-key 'normal org-mode-map (kbd "S-<down>") 'org-move-subtree-down)
  (evil-define-key 'normal org-mode-map (kbd "S-<right>") 'org-demote-subtree)

  (evil-define-key 'normal org-mode-map (kbd "C-S-<left>") 'org-do-promote)
  (evil-define-key 'normal org-mode-map (kbd "C-S-<right>") 'org-do-demote)
#+END_SRC
*** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation t)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: E \equal{} \gamma{}mc^2
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-pretty-entities t)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]].
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; ⚫•⦾⦿—⬎⌄⌵
  (setq org-bullets-bullet-list '("•"))
  (setq org-ellipsis " ⌵")
  (setq ic/org-list-icon "—")
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 ()
           (compose-region (match-beginning 1)
                           (match-end 1)
                           ic/org-list-icon))))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-hide-emphasis-markers t)
#+END_SRC
*** Agenda
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)
  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)
  ;; show weekly agenda by default
  (setq org-agenda-span 'week)
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(("a" "Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            (tags "-refile/"
                  ((org-agenda-overriding-header "Archive tasks:")
                   (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                   (org-tags-match-list-sublevels nil))))
           ((org-agenda-block-separator "1")
            (org-agenda-compact-blocks t)
            (org-agenda-tag-filter-preset '("-HOME"))
            ))
          ("h" "Home agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            (tags "-refile/"
                  ((org-agenda-overriding-header "\nArchive tasks:")
                   (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                   (org-tags-match-list-sublevels nil)))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores|jobs"
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))))
            )
           ((org-agenda-block-separator "1")
            (org-agenda-compact-blocks t)
            (org-agenda-tag-filter-preset '("+HOME"))
            ))
          ))
  ;; don't have a separator between agenda sections
  (setq org-agenda-block-separator "2")
  (setq org-agenda-compact-blocks nil)
#+END_SRC
*** Habits
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 2)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today t)
#+END_SRC
*** Todo
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(a@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC
*** Logging
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC
*** Capture
**** Templates
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)
  (setq org-capture-templates
        '(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume)
          ("r" "respond" entry (file org-default-notes-file)
           "* TODO respond to %:from on %:subject\nscheduled: %t\n%u\n%a\n"
           :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume :immediate-finish t)
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume)
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume)
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume)
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name} :uncooked::\n:properties:\n:source: %^{source}\n:image: %^{image}\n:serving: %^{serving}\n:type: %^{type}\n:end:\n** ingredients\n   | %? | |\n** procedure\n   1.\n** log")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")
          ))
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

**** Full Frame
The standard =org-capture= behavior is to split the window before capturing a
task. When this is started from outside emacs a random buffer occupies half the
frame. What I want is the capture buffer to take the full frame when starting
the capture from outside emacs. My window manager will start the capture task
with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook
where it splits the frame we'll need to advise it to ~(delete-other-windows)~
when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC
*** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :tangle no
  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; show current clock in the modeline
  (setq spacemacs-mode-line-org-clock-current-taskp t)
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  (org-clock-persistence-insinuate)
#+END_SRC
*** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp :tangle yes\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml :tangle yes\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
#+END_SRC
*** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want
to see most everything else.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC
*** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/org-recipe-publish-to-html (plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC
** TODO disk-usage
So we can see how much crap there is.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package disk-usage)
#+END_SRC
** mu4e
First, setup mu.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-maildir "~/mail")
  ;; (setq mu4e-mu-binary "/usr/local/bin/mu")
  (setq mu4e-get-mail-command "offlineimap -o")
#+END_SRC

We can only check our gmail accounts once every 10 minutes or we risk a ban.
#+BEGIN_QUOTE
Make sure your mail app isn't set to check for new email too frequently. If your mail app checks for new messages more than once every 10 minutes, the app’s access to your account could be blocked.
#+END_QUOTE
More information [[https://support.google.com/mail/answer/7126229?p=BadCredentials&visit_id=636868193607658613-796315695&rd=2#cantsignin][here]].

#+BEGIN_SRC emacs-lisp :tangle no
  (setq mu4e-update-interval 600)
#+END_SRC

Then, some common variables.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; show images inline
  (setq mu4e-view-show-images t)
  (setq mu4e-show-images t)
  ;; show addresses rather than names
  (setq mu4e-view-show-addresses t)
  ;; strip html when viewing emails...
  (setq mu4e-html2text-command "w3m -dump -T text/html")
  ;; ... and allow me to open an email in a browser
  (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser) t)
  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
  ;; quit silently
  (setq mu4e-confirm-quit nil)
#+END_SRC

Have a slightly different layout when showing an inbox.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; different date format
  (setq mu4e-headers-date-format "%Y-%m-%d %H:%M")
  ;; set header fields
  (setq mu4e-headers-fields
        '((:date    . 17)
          (:flags   . 6)
          (:from    . 32)
          (:subject . nil)))
#+END_SRC

We need a helper function to determine what context we're in automatically.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; taken from: https://notanumber.io/2016-10-03/better-email-with-mu4e/
  (defun ic//mu4e-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
            ;; If rx is a list, try each one for a match
            (or (ic//mu4e-maildir-matches msg (car rx))
                (ic//mu4e-maildir-matches msg (cdr rx)))
          ;; Not a list, check rx
          (string-match rx (mu4e-message-field msg :maildir)))))
#+END_SRC

Some default gmail setup.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq message-send-mail-function 'smtpmail-send-it)
  ;; (setq smtpmail-default-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-service 587)
  ;; (setq smtpmail-stream-type 'starttls)
  ;; (setq smtpmail-smtp-local-domain "gmail.com")
#+END_SRC

For each of our gmail accounts we need an application specific password to use
to send email. To create one go [[https://security.google.com/settings/u/1/security/apppasswords][here]]. Be sure and insert a line into
=~/.authinfo.gpg= for each account with the following format:
#+BEGIN_EXAMPLE
machine smtp.gmail.com port 587 login <user>@gmail.com password <account password>
#+END_EXAMPLE

Now some account specific setup
#+BEGIN_SRC emacs-lisp :tangle no
  ;; This sets up my two different context for my personal and work emails.
  (setq mu4e-contexts
        (let ((professional-address (ic/read-secret "gmail-professional" "address"))
              (professional-name (ic/read-secret "gmail-professional" "name"))
              (personal-address (ic/read-secret "gmail-personal" "address"))
              (personal-name (ic/read-secret "gmail-personal" "name")))
          `( ,(make-mu4e-context
               :name "professional-gmail"
               :enter-func `(lambda () (mu4e-message (concat "Switch to " ,professional-address)))
               :match-func (lambda (msg)
                             (when msg
                               (ic//mu4e-maildir-matches msg "^/gmail-professional")))
               :leave-func (lambda () (mu4e-clear-caches))
               :vars `((user-mail-address     . ,professional-address)
                       (user-full-name        . ,professional-name)
                       (mu4e-sent-folder      . "/gmail-professional/sent")
                       (mu4e-drafts-folder    . "/gmail-professional/drafts")
                       (mu4e-trash-folder     . "/gmail-professional/trash")
                       (mu4e-refile-folder    . "/gmail-professional/inbox") ; XXX What should this be?
                       (smtpmail-smtp-user    . ,professional-address)
                       ))
              ,(make-mu4e-context
                :name "home-gmail"
                :enter-func (lambda () `(mu4e-message (concat "Switch to " ,personal-address)))
                :match-func (lambda (msg)
                              (when msg
                                (ic//mu4e-maildir-matches msg "^/gmail-personal")))
                :leave-func (lambda () (mu4e-clear-caches))
                :vars `((user-mail-address     . ,personal-address)
                        (user-full-name        . ,personal-name)
                        (mu4e-sent-folder      . "/gmail-personal/sent")
                        (mu4e-drafts-folder    . "/gmail-personal/drafts")
                        (mu4e-trash-folder     . "/gmail-personal/trash")
                        (mu4e-refile-folder    . "/gmail-personal/inbox")
                        (smtpmail-smtp-user    . ,personal-address)
                        )))))

  ;; compose under the current context
  (setq mu4e-compose-context-policy nil)
#+END_SRC

Message composing should be done in =org-mode= format and sent as html.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; automatically flow text when sending
  (setq mu4e-compose-format-flowed t)

  ;; enter org-mode when composing
  (add-hook 'message-mode-hook 'org-mu4e-compose-org-mode)

  ;; export org-mode into html when sending
  (setq org-mu4e-convert-to-html t)

  ;; (setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC
** Recipes
*** Configuration
First, we need to setup some configuration.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar ic/recipes-org-file "~/org/home/recipes/recipes.org")
  (defvar ic/recipes-www-dir "~/www/recipes")
#+END_SRC
*** Parsing
For the export we want to iterate though the org file, looking for recipes,
export those recipes individually, then build the table of contents.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/recipes-export ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents ic/recipes-org-file)
      ;; (org-show-subtree)
      (org-element-map (org-element-parse-buffer) 'headline
        (lambda (elem)
          (when (ic//is-recipe-p elem)
            (ic//recipes-export-single (ic//recipes-parse-recipe elem)))))))

  ;; XXX temp keybinding while testing
  (global-set-key (kbd "<f2>") 'ic/recipes-export)
#+END_SRC

We define a recipe as a headline with two specific child headlines: =Ingredients=
and =Steps=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic//is-recipe-p (elem)
    (and (ic/org-element-find-child elem 'headline "Ingredients")
         (ic/org-element-find-child elem 'headline "Steps")))
#+END_SRC

Find the immediate children of an element
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/org-element-children (elem type)
    (org-element-map elem type
      (lambda (child)
        (let ((parent (org-element-property :parent child)))
          (when (eq parent elem)
            child)))))

  (defun ic/org-element-find-child (elem type child-name)
    (seq-filter
     (lambda (child)
       (equal child-name
              (org-element-property :raw-value child)))
     (ic/org-element-children elem type)))
#+END_SRC

For some reason the both the =:tags= property of =org-property= and =org-get-tags=
only return the local tags for a headline, even when =org-use-tag-inheritance= is
=t=. I want tag inheritance, so let's define a function to do that.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/org-element-tags (elem)
    (let ((tags (org-element-property :tags elem))
          (parent (org-element-property :parent elem)))
      (if (and org-use-tag-inheritance parent)
          (delete-dups (append tags (ic/org-element-tags parent)))
        tags)))
#+END_SRC

Given an =org= heading we need a function to parse a recipe.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic//recipes-parse-recipe (elem)
    (let ((name (org-element-property :raw-value elem))
          (tags (ic/org-element-tags elem))
          (ingredients (ic//recipes-get-child-list
                        (ic/org-element-find-child elem 'headline "Ingredients")))
          (steps (ic//recipes-get-child-list
                  (ic/org-element-find-child elem 'headline "Steps")))
          )
      (when (not (and ingredients steps))
        (error (format "invalid recipe '%s': must have headlines Ingredients and Steps" name)))
      `((name . ,name)
        (tags . ,tags)
        (ingredients . ,ingredients)
        (steps . ,steps)
        )))

  ;; (defun ic/org-element-to-text (elem)
  ;;   (let ((start (org-element-property :contents-begin elem))
  ;;         (end (org-element-property :contents-end elem)))
  ;;     (buffer-substring start (- end 1))))

  (defun ic//recipes-get-child-list (elem)
    (mapcar
     (lambda (elem)
       (let ((start (org-element-property :contents-begin elem))
             (end (org-element-property :contents-end elem)))
         (buffer-substring start (- end 1))))
     (org-element-map elem 'item #'identity nil nil 'item)))

  (defun ic//recipes-org-list-to-list (elem)
    (mapcar
     (lambda (item) "foo")
     ;; (lambda (item) (org-element-property :bullet item))
     (ic/org-element-children elem nil)))
#+END_SRC
*** Exporting
Test for exporting a recipe.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic//recipes-export-single (recipe)
    (message "%S" recipe)
    )
#+END_SRC
*** Old
TODO: I can't figure out how to get =org-publish= to write each headline to a
separate html file.
See [[*Exporting][Exporting]].
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/recipes"
           :base-extension "org"
           :publishing-directory "~/recipes"
           :publishing-function org-html-publish-to-html
           :with-properties t
           :with-tags t
           :auto-sitemap t
           :html-postamble nil

           :exclude "PrivatePage.org"
           :headline-levels 3
           :section-numbers nil
           :with-toc nil
           :html-head "<link rel=\"stylesheet\" href=\"../other/mystyle.css\" type=\"text/css\"/>"
           :html-preamble t
           )))
#+END_SRC
* Programming
** General
*** Indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/setup-indentation-hook (tab-width use-tabs)
    "Create a mode-hook that will setup indentation variables."
    `(lambda ()
       (setq indent-tabs-mode ,use-tabs)
       (setq tab-width ,tab-width)
       (setq js-indent-level ,tab-width)
       (setq python-indent ,tab-width)))
  (let ((indentation-setup
         '(
           (asm-mode-hook 8 t)
           (emacs-lisp-mode-hook 2 nil)
           (lisp-mode-hook 2 nil)
           (makefile-mode-hook 8 t)
           (python-mode-hook 4 nil)
           )))
    (dolist (elem indentation-setup)
      (add-hook (car elem)
                (apply #'ic/setup-indentation-hook (cdr elem)))))
  ;; use tabs by default
  (setq-default indent-tabs-mode t)
  (setq-default tab-width 4)
#+END_SRC
** Python
*** Linter
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq flycheck-checker-error-threshold 1024)
#+END_SRC
** Lisp
*** Indentation
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; better indentation of quoted lists
  (setq lisp-indent-function 'common-lisp-indent-function)
#+END_SRC
* Misc
** Fonts
Setup both monospaced and non-monospaced fonts.

Some good variable spaced fonts:
- Century Schoolbook L
- TeX Gyre Pagella
- Utopia
- Caladea
- Gentium
- Gillius ADF
- URW Palladio L

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar ic/fixed-pitch-font '("DejaVu Sans Mono" 11.0))
  (defvar ic/variable-pitch-font '("Gillius ADF" 13.0))

  (defun ic/setup-fonts (fixed-pitch-font variable-pitch-font)
    (cl-flet ((make-size (size)
             (truncate (* 10 size))))
      (let ((fixed-family (first fixed-pitch-font))
            (fixed-height (make-size (second fixed-pitch-font)))
            (variable-family (first variable-pitch-font))
            (variable-height (make-size (second variable-pitch-font))))
        (custom-theme-set-faces
         'user
         `(default ((t (:family ,fixed-family :height ,fixed-height))))
         `(fixed-pitch ((t (:family ,fixed-family :height ,fixed-height))))
         `(variable-pitch ((t (:family ,variable-family :height ,variable-height))))
         ))))
  (ic/setup-fonts ic/fixed-pitch-font ic/variable-pitch-font)
#+END_SRC

** Variable pitch
=org-mode= should be mostly variable pitch with only code and =company-mode= being
fixed width.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar ic/org-faces-fixed-pitch
    '(company-echo
      company-echo-common
      company-preview
      company-preview-common
      company-preview-search
      company-scrollbar-bg
      company-scrollbar-fg
      company-template-field
      company-tooltip
      company-tooltip-annotation
      company-tooltip-annotation-selection
      company-tooltip-common
      company-tooltip-common-selection
      company-tooltip-mouse
      company-tooltip-search
      company-tooltip-search-selection
      company-tooltip-selection
      linum
      org-block
      org-block-begin-line
      org-block-end-line
      org-checkbox
      org-code
      org-document-info-keyword
      org-hide
      org-indent
      org-link
      org-meta-line
      org-special-keyword
      org-table
      whitespace-space
      )
    "A list of faces that should remain fixed width when enabling `variable-pitch-mode'.")

  (defun ic//variable-pitch-add-inherit (attrs parent)
    "Add `:inherit PARENT' to ATTRS unless already present. Handles cases where :inherit is already specified."
    (let ((current-parent (plist-get attrs :inherit)))
      (unless (or (eq parent current-parent)
                  (and (listp current-parent) (member parent current-parent)))
        (plist-put attrs :inherit (if current-parent
                                      (list current-parent parent)
                                    parent)))))

  (defun ic/variable-pitch-mode ()
    (variable-pitch-mode 1)
    (mapc
     (lambda (face)
       (when (facep face)
         (apply 'set-face-attribute
                face nil (ic//variable-pitch-add-inherit
                          (face-attr-construct face)
                          'fixed-pitch))))
     ic/org-faces-fixed-pitch))

  (add-hook 'org-mode-hook #'ic/variable-pitch-mode)
#+END_SRC
** Web Browser
Use whatever we have as =web= as default browser
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "web")
#+END_SRC
** Clipboard
Use system clipboard
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq x-select-enable-primary t)
#+END_SRC
** Line Numbers
Use static line numbers everywhere. I want to use relative, but found a
significant performance hit when doing so. Using =helm= was especially painful.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-linum-mode)
  (linum-relative-global-mode -1)
#+END_SRC

** Text Wrap
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Fill Column
#+BEGIN_SRC emacs-lisp :tangle yes
  (turn-on-fci-mode)
#+END_SRC
** Search
Disable search highlighting
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-evil-search-highlight-persist 0)
#+END_SRC
** Customize
Disable customize by having emacs write customize variables to a file that is
never loaded.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file (concat user-emacs-directory "ignore-custom.el"))
#+END_SRC
** Helm
*** Keybinds
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key helm-map (kbd "C-w") 'backward-kill-word)
#+END_SRC
** Evil
*** Keybinds
When editing an =org-src= block =:w= should save the parent buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/evil-save-src-block-advice (evil-write &rest args)
    "When edit an org-src block `:w' should call `(org-edit-src-save)'."
    (if (string-prefix-p "*Org Src" (buffer-name))
        (org-edit-src-save)
      (apply evil-write args)))

  (advice-add #'evil-write :around #'ic/evil-save-src-block-advice)
#+END_SRC
** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to
use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic/save-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (let ((spacemacs-really-kill-emacs nil))
      (save-buffer)
      (kill-buffer-and-window)))

  (defun ic/prompt-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (let ((spacemacs-really-kill-emacs t))
        (save-buffers-kill-emacs))))

  ;; set spacemacs keys
  (spacemacs/set-leader-keys "qq" 'spacemacs/frame-killer)
  (spacemacs/set-leader-keys "qQ" 'ic/prompt-kill-emacs)

  ;; set evil keys
  (evil-ex-define-cmd "q[uit]" 'kill-buffer-and-window)
  (evil-ex-define-cmd "wq" 'ic/save-kill-buffer-and-window)
#+END_SRC

* Refile
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq create-lockfiles nil)
  (setq magit-diff-refine-hunk 'all)
  (setq powerline-default-separator 'contour)
#+END_SRC
